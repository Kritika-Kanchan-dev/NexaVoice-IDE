import tkinter as tk
from tkinter import scrolledtext, filedialog, messagebox
import speech_recognition as sr
import threading
import os  # <-- New
from dotenv import load_dotenv  # <-- New
from llm_integration import GeminiCodeAssistant  # <-- Our new module!

class VoiceCodeIDE:
    def __init__(self, root):
        self.root = root
        self.root.title("Voice-Powered Code Editor")
        self.root.geometry("900x700")

        # --- Gemini Initialization ---
        load_dotenv()  # Loads variables from .env file
        gemini_api_key = os.getenv("API_KEY")
        if not gemini_api_key:
            messagebox.showerror("Config Error", "Gemini API key not found in .env file. Please set it as API_KEY=your_key.")
            self.root.destroy()
            return
        # Create an instance of our assistant
        self.gemini_assistant = GeminiCodeAssistant(api_key=gemini_api_key)
        # --- End Gemini Initialization ---

        # ... (the rest of your _init_ stays the same) ...
        self.text_editor = scrolledtext.ScrolledText(root, wrap=tk.WORD, font=("Consolas", 12))
        self.text_editor.pack(expand=True, fill='both', padx=10, pady=10)

        self.status_bar = tk.Label(root, text="Status: Ready", bd=1, relief=tk.SUNKEN, anchor=tk.W)
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)

        self.listen_button = tk.Button(root, text="Start Listening", command=self.start_listening_thread)
        self.listen_button.pack(side=tk.BOTTOM, pady=10)

        self.recognizer = sr.Recognizer()
        self.microphone = sr.Microphone()

    def update_status(self, message):
        self.status_bar.config(text=f"Status: {message}")

    def start_listening_thread(self):
        self.listen_button.config(state=tk.DISABLED, text="Listening...")
        self.update_status("Listening for a command...")
        thread = threading.Thread(target=self.listen_for_command)
        thread.daemon = True
        thread.start()

    def listen_for_command(self):
        try:
            with self.microphone as source:
                self.recognizer.adjust_for_ambient_noise(source)
                audio = self.recognizer.listen(source)
            
            command = self.recognizer.recognize_google(audio).lower()
            self.update_status(f"Recognized: '{command}'")
            
            # Execute command in the main UI thread
            self.root.after(0, self.execute_command, command)

        except sr.UnknownValueError:
            self.update_status("Could not understand audio. Please try again.")
        except sr.RequestError as e:
            self.update_status(f"API error: {e}")
        finally:
            # Re-enable the button in the main UI thread
            self.root.after(0, lambda: self.listen_button.config(state=tk.NORMAL, text="Start Listening"))

    def execute_command(self, command):
        """
        Interprets the command and acts accordingly.
        This is the new, simplified logic!
        """
        if "open code" in command:
            self.open_file()
        elif "save file" in command:
            self.save_file()
        else:
            # --- NEW LLM LOGIC ---
            # If it's not a file command, assume it's a code generation request
            self.update_status(f"ðŸ¤– Sending to Gemini: '{command}'...")
            self.root.update_idletasks() # Force UI to update to show "Sending..." message

            # Call our Gemini module to get the code
            generated_code = self.gemini_assistant.generate_code(command)
            
            # Check if Gemini returned an error
            if generated_code.strip().startswith("# ERROR"):
                self.update_status(f"âš ï¸ {generated_code}")
            else:
                self.text_editor.insert(tk.INSERT, generated_code + "\n\n")
                self.update_status("âœ… Code generated by Gemini.")
            # --- END NEW LOGIC ---

    def save_file(self):
        file_path = filedialog.asksaveasfilename(defaultextension=".py",
                                                 filetypes=[("Python files", "*.py"), ("All files", "*.*")])
        if file_path:
            with open(file_path, 'w') as file:
                file.write(self.text_editor.get(1.0, tk.END))
            self.update_status(f"File saved to {file_path}")

    def open_file(self):
        file_path = filedialog.askopenfilename(filetypes=[("Python files", "*.py"), ("All files", "*.*")])
        if file_path:
            with open(file_path, 'r') as file:
                self.text_editor.delete(1.0, tk.END)
                self.text_editor.insert(tk.INSERT, file.read())
            self.update_status(f"File opened from {file_path}")

if __name__ == "__main__":
    root = tk.Tk()
    app = VoiceCodeIDE(root)
    root.mainloop()

