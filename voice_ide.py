import tkinter as tk
from tkinter import scrolledtext, filedialog, messagebox
import speech_recognition as sr
import threading
import os
from dotenv import load_dotenv
from llm_integration import GeminiCodeAssistant  

def format_markdown_for_tk(text):
    lines = text.split("\n")
    formatted = []

    inside_code_block = False

    for line in lines:
        # Remove ```python or ```
        if line.strip().startswith("```"):
            inside_code_block = not inside_code_block
            formatted.append("\n--------------- CODE ----------------\n")
            continue

        # Inside code block ‚Üí indent code for readability
        if inside_code_block:
            formatted.append("    " + line)
            continue

        # Format headings
        if line.startswith("###"):
            formatted.append("\n" + line.replace("###", "").strip().upper())
            formatted.append("-" * 40)
            continue

        # Remove bold markdown
        line = line.replace("**", "")

        # Bullet points
        if line.strip().startswith("* "):
            formatted.append(" ‚Ä¢ " + line.replace("*", "").strip())
            continue
        
        formatted.append(line)

    return "\n".join(formatted)


class VoiceCodeIDE:
    def __init__(self, root):
        self.root = root
        self.root.title("Voice-Powered Code Editor")
        self.root.geometry("900x700")

        load_dotenv()
        gemini_api_key = os.getenv("API_KEY")
        if not gemini_api_key:
            messagebox.showerror("Config Error", "Gemini API key not found in .env file. Please set it as API_KEY=your_key.")
            self.root.destroy()
            return

        self.gemini_assistant = GeminiCodeAssistant(api_key=gemini_api_key)

        self.text_editor = scrolledtext.ScrolledText(root, wrap=tk.WORD, font=("Consolas", 12))
        self.text_editor.pack(expand=True, fill='both', padx=10, pady=10)

        self.status_bar = tk.Label(root, text="Status: Ready", bd=1, relief=tk.SUNKEN, anchor=tk.W)
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)

        self.listen_button = tk.Button(root, text="Start Listening", command=self.start_listening_thread)
        self.listen_button.pack(side=tk.BOTTOM, pady=10)

        self.debug_button = tk.Button(root, text="Open Debug Window", command=self.open_debug_window)
        self.debug_button.pack(side=tk.BOTTOM, pady=10)


        self.recognizer = sr.Recognizer()
        self.microphone = sr.Microphone()

    def update_status(self, message):
        self.status_bar.config(text=f"Status: {message}")

    def start_listening_thread(self):
        self.listen_button.config(state=tk.DISABLED, text="Listening...")
        self.update_status("Listening for a command...")
        thread = threading.Thread(target=self.listen_for_command)
        thread.daemon = True
        thread.start()

    def listen_for_command(self):
        try:
            with self.microphone as source:
                self.recognizer.adjust_for_ambient_noise(source)
                audio = self.recognizer.listen(source)
            
            command = self.recognizer.recognize_google(audio).lower()
            self.update_status(f"Recognized: '{command}'")
            
            self.root.after(0, self.execute_command, command)

        except sr.UnknownValueError:
            self.update_status("Could not understand audio. Please try again.")
        except sr.RequestError as e:
            self.update_status(f"API error: {e}")
        finally:
            self.root.after(0, lambda: self.listen_button.config(state=tk.NORMAL, text="Start Listening"))

    def execute_command(self, command):
        """
        Interprets the command and acts accordingly.
        This is the new, simplified logic!
        """
        if "open code" in command:
            self.open_file()
        elif "save file" in command:
            self.save_file()
        else:
            self.update_status(f"ü§ñ Sending to Gemini: '{command}'...")
            self.root.update_idletasks()

            generated_code = self.gemini_assistant.generate_code(command)
            
            if generated_code.strip().startswith("# ERROR"):
                self.update_status(f"‚ö†Ô∏è {generated_code}")
            else:
                self.text_editor.insert(tk.INSERT, generated_code + "\n\n")
                self.update_status("‚úÖ Code generated by Gemini.")

    def save_file(self):
        file_path = filedialog.asksaveasfilename(defaultextension=".py",
                                                 filetypes=[("Python files", "*.py"), ("All files", "*.*")])
        if file_path:
            with open(file_path, 'w') as file:
                file.write(self.text_editor.get(1.0, tk.END))
            self.update_status(f"File saved to {file_path}")

    def open_file(self):
        file_path = filedialog.askopenfilename(filetypes=[("Python files", "*.py"), ("All files", "*.*")])
        if file_path:
            with open(file_path, 'r') as file:
                self.text_editor.delete(1.0, tk.END)
                self.text_editor.insert(tk.INSERT, file.read())
            self.update_status(f"File opened from {file_path}")

    def open_debug_window(self):
        debug_window = tk.Toplevel(self.root)
        debug_window.title("Debug Code")
        debug_window.geometry("900x700")

        # ------------ INPUT LABEL -------------
        tk.Label(debug_window, text="Paste Your Code Below:", font=("Calibri", 12, "bold")).pack(pady=5)

        # ------------ INPUT BOX -------------
        input_box = scrolledtext.ScrolledText(debug_window, wrap=tk.WORD, height=12, font=("Consolas", 12))
        input_box.pack(fill="both", padx=10, pady=10, expand=False)

        # ------------ BUTTON SECTION -------------
        button_frame = tk.Frame(debug_window)
        button_frame.pack(pady=10)



        # ---- DEBUG BUTTON ----
        def run_debug():
            code = input_box.get("1.0", tk.END)
            if not code.strip():
                messagebox.showwarning("Empty", "Please paste some code first.")
                return

            output_box.delete("1.0", tk.END)
            output_box.insert(tk.END, "Debugging... Please wait.\n")

            try:
                result = self.gemini_assistant.debug_code(code)
                formatted = format_markdown_for_tk(result)
                output_box.delete("1.0", tk.END)
                output_box.insert(tk.END, formatted)
            except Exception as e:
                output_box.insert(tk.END, f"\nError: {str(e)}")

        tk.Button(
            button_frame,
            text="DEBUG CODE",
            command=run_debug,
            bg="blue",
            fg="white",
            padx=10,
            pady=5
        ).pack(side=tk.LEFT, padx=5)

        # ---- AUTO FIX BUTTON ----
        def auto_fix():
            code = input_box.get("1.0", tk.END)
            if not code.strip():
                messagebox.showwarning("Empty", "Please paste some code first.")
                return

            output_box.delete("1.0", tk.END)
            output_box.insert(tk.END, "Fixing code... please wait.\n")

            try:
                fixed = self.gemini_assistant.auto_fix_code(code)
                formatted = format_markdown_for_tk(fixed)
                output_box.delete("1.0", tk.END)
                output_box.insert(tk.END, formatted)

            except Exception as e:
                output_box.delete("1.0", tk.END)
                output_box.insert(tk.END, f"Error: {str(e)}")

        tk.Button(
            button_frame,
            text="AUTO FIX CODE",
            command=auto_fix,
            bg="#0ea5e9",
            fg="white",
            padx=10,
            pady=5
        ).pack(side=tk.LEFT, padx=5)

        # ---- COPY FIXED CODE BUTTON ----
        def copy_fixed_code():
            fixed_code = output_box.get("1.0", tk.END).strip()
            if not fixed_code:
                messagebox.showwarning("Empty", "There is no fixed code to copy!")
                return

            debug_window.clipboard_clear()
            debug_window.clipboard_append(fixed_code)
            messagebox.showinfo("Copied", "Corrected code has been copied to the clipboard!")

        tk.Button(
            button_frame,
            text="COPY OUTPUT CODE",
            command=copy_fixed_code,
            bg="#10b981",
            fg="white",
            padx=10,
            pady=5
        ).pack(side=tk.LEFT, padx=5)

        def generate_tests():
            code = input_box.get("1.0", tk.END).strip()
            if not code:
                messagebox.showwarning("Empty", "Please paste some code first.")
                return

            output_box.delete("1.0", tk.END)
            output_box.insert(tk.END, "Generating test cases... please wait.\n")

            try:
                tests = self.gemini_assistant.generate_test_cases(code)
                formatted = format_markdown_for_tk(tests)
                output_box.delete("1.0", tk.END)
                output_box.insert(tk.END, formatted)

            except Exception as e:
                output_box.delete("1.0", tk.END)
                output_box.insert(tk.END, f"Error: {str(e)}")

        tk.Button(
            button_frame,
            text="GENERATE TEST CASES",
            command=lambda: generate_tests(),
            bg="#f59e0b",
            fg="white",
            padx=10,
            pady=5
        ).pack(side=tk.LEFT, padx=5)


        # ------------ OUTPUT LABEL -------------
        tk.Label(debug_window, text="Debug Output:", font=("Calibri", 12, "bold")).pack(pady=5)

        # ------------ OUTPUT BOX -------------
        output_box = scrolledtext.ScrolledText(debug_window, wrap=tk.WORD, height=18, font=("Consolas", 12))
        output_box.pack(fill="both", padx=10, pady=10, expand=True)



if __name__ == "__main__":
    root = tk.Tk()
    app = VoiceCodeIDE(root)
    root.mainloop()

